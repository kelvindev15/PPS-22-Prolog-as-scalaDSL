"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[821],{3905:(e,t,i)=>{i.d(t,{Zo:()=>c,kt:()=>g});var n=i(7294);function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function a(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?r(Object(i),!0).forEach((function(t){o(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function l(e,t){if(null==e)return{};var i,n,o=function(e,t){if(null==e)return{};var i,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||(o[i]=e[i]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(o[i]=e[i])}return o}var u=n.createContext({}),s=function(e){var t=n.useContext(u),i=t;return e&&(i="function"==typeof e?e(t):a(a({},t),e)),i},c=function(e){var t=s(e.components);return n.createElement(u.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var i=e.components,o=e.mdxType,r=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(i),m=o,g=d["".concat(u,".").concat(m)]||d[m]||p[m]||r;return i?n.createElement(g,a(a({ref:t},c),{},{components:i})):n.createElement(g,a({ref:t},c))}));function g(e,t){var i=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=i.length,a=new Array(r);a[0]=m;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[d]="string"==typeof e?e:o,a[1]=l;for(var s=2;s<r;s++)a[s]=i[s];return n.createElement.apply(null,a)}return n.createElement.apply(null,i)}m.displayName="MDXCreateElement"},5968:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var n=i(7462),o=(i(7294),i(3905));const r={sidebar_position:3,sidebar_label:"Design dettagliato"},a="Design dettagliato",l={unversionedId:"documentazione/detailed_design",id:"documentazione/detailed_design",title:"Design dettagliato",description:"Di seguito verr\xe0 riportato il design dettagliato della libreria.",source:"@site/docs/documentazione/detailed_design.md",sourceDirName:"documentazione",slug:"/documentazione/detailed_design",permalink:"/PPS-22-Prolog-as-scalaDSL/docs/documentazione/detailed_design",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Design dettagliato"},sidebar:"docSidebar",previous:{title:"Design architetturale",permalink:"/PPS-22-Prolog-as-scalaDSL/docs/documentazione/architectural_design"},next:{title:"Implementazione",permalink:"/PPS-22-Prolog-as-scalaDSL/docs/documentazione/implementation"}},u={},s=[{value:"Term",id:"term",level:2},{value:"Constant",id:"constant",level:2},{value:"Variabili",id:"variabili",level:2},{value:"Struct",id:"struct",level:2},{value:"Indicator",id:"indicator",level:3},{value:"Clause",id:"clause",level:3},{value:"RecursiveStruct",id:"recursivestruct",level:3},{value:"Theory",id:"theory",level:2},{value:"Modello del dominio riconciliato",id:"modello-del-dominio-riconciliato",level:2},{value:"PrologProgram",id:"prologprogram",level:2},{value:"Solver",id:"solver",level:2},{value:"Solution",id:"solution",level:3},{value:"Substitution",id:"substitution",level:3},{value:"PrologDSL",id:"prologdsl",level:2},{value:"TermConvertible",id:"termconvertible",level:2},{value:"TermVisitor",id:"termvisitor",level:2}],c={toc:s},d="wrapper";function p(e){let{components:t,...i}=e;return(0,o.kt)(d,(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"design-dettagliato"},"Design dettagliato"),(0,o.kt)("p",null,"Di seguito verr\xe0 riportato il design dettagliato della libreria."),(0,o.kt)("h2",{id:"term"},"Term"),(0,o.kt)("p",null,"Il trait Term rappresenta il concetto di termine in Prolog. Costituisce l'entit\xe0 fondamentale dalla quale ereditano tutti\ngli altri costrutti del linguaggio prolog."),(0,o.kt)("p",null,"All'interno della struttura di un termine possono trovarsi delle variabili. La presenza o meno delle variabili,\ndetermina se si tratta o meno di un termine base."),(0,o.kt)("h2",{id:"constant"},"Constant"),(0,o.kt)("p",null,"Una costante \xe8 un termine che racchiude un valore che pu\xf2 essere alfanumerico o numerico.\nLe costanti alfanumeriche sono atomi rappresentati dal trai Atom, mentre le costanti numeriche sono\nrappresentate dal trait Numeric. "),(0,o.kt)("p",null,"Un atomo \xe8 un caso particolare di termine composto."),(0,o.kt)("h2",{id:"variabili"},"Variabili"),(0,o.kt)("p",null,"Una variabile ha un nome particolare oppure \xe8 anonima (il suo nome \xe8 ",(0,o.kt)("inlineCode",{parentName:"p"},"_"),")."),(0,o.kt)("h2",{id:"struct"},"Struct"),(0,o.kt)("p",null,"I termini composti, detti anche strutture, sono rappresentati dal trait Struct. Ogni termine \xe8 caratterizzato da un funtore, ossia un nome di\npredicato, e dai sui argomenti, che sono a loro volta dei termini. Il numero di argomenti di cui \xe8 costituito un termine\ncomposto determina l'arit\xe0 del termine composto."),(0,o.kt)("h3",{id:"indicator"},"Indicator"),(0,o.kt)("p",null,"Un indicatore \xe8 un termine composto che descrive un predicato in termini del suo funtore e della sua arit\xe0.\nIl funtore di un incatore \xe8 il carattere ",(0,o.kt)("inlineCode",{parentName:"p"},"/")," e la sua arit\xe0 ",(0,o.kt)("inlineCode",{parentName:"p"},"2"),"."),(0,o.kt)("h3",{id:"clause"},"Clause"),(0,o.kt)("p",null,"Anche le clausole, rappresentate dal trait Clause sono strutture il cui funtore \xe8 ",(0,o.kt)("inlineCode",{parentName:"p"},":-"),"."),(0,o.kt)("p",null,"Esistono tre principali tipi di clausole:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Regole"),": clausola con una testa e un corpo. La testa di una regola \xe8 una struttura mentre il corpo \xe8 un termine."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Fatti"),": clausola con solo una testa. Anche in questo caso la testa di un fatto \xe8 una struttura. Un fatto pu\xf2 essere\nconsiderato una regola il cui corpo \xe8 il l'atomo ",(0,o.kt)("inlineCode",{parentName:"li"},"true"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Direttive"),": clausola con solo un corpo. Anche in questo caso il corpo \xe8 un termine.")),(0,o.kt)("h3",{id:"recursivestruct"},"RecursiveStruct"),(0,o.kt)("p",null,"Alcuni termini composti hanno una struttura ricorsiva. Sono strutture i cui argomenti includono in maniera ricorsiva\nstrutture con lo stesso predicato.\nDa una struttura \xe8 sempre possibile ottenere la lista lineare degli argomenti."),(0,o.kt)("p",null,"La maggior parte delle strutture ricorsive sono binarie (BinaryRecursiveStruct). \xc8 il caso di:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Congiunzioni di goal (Conjunction), con funtore ",(0,o.kt)("inlineCode",{parentName:"li"},","),";"),(0,o.kt)("li",{parentName:"ul"},"Disgiunzioni di goal (Disjunction), con funtore ",(0,o.kt)("inlineCode",{parentName:"li"},";"),";"),(0,o.kt)("li",{parentName:"ul"},"Liste (PrologList), con funtore ricorsivo ",(0,o.kt)("inlineCode",{parentName:"li"},".")," (Cons). Ogni lista termina con il funtore ",(0,o.kt)("inlineCode",{parentName:"li"},"[]")," (Nil).")),(0,o.kt)("h2",{id:"theory"},"Theory"),(0,o.kt)("p",null,"Una teoria \xe8 rappresentata dal trait Theory. Una teoria \xe8 una lista di clausole."),(0,o.kt)("h2",{id:"modello-del-dominio-riconciliato"},"Modello del dominio riconciliato"),(0,o.kt)("h2",{id:"prologprogram"},"PrologProgram"),(0,o.kt)("p",null,"Un programma prolog (PrologProgram) comprende:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Una teoria dinamica"),(0,o.kt)("li",{parentName:"ul"},"Una teoria statica"),(0,o.kt)("li",{parentName:"ul"},"Un goal")),(0,o.kt)("h2",{id:"solver"},"Solver"),(0,o.kt)("p",null,"Un Solver risolve un goal o un programma prolog e restituisce le sue soluzioni.\nUn solver pu\xf2:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"restituire una soluzione alla volta;"),(0,o.kt)("li",{parentName:"ul"},"restituire tutte le soluzioni in una lista. ")),(0,o.kt)("h3",{id:"solution"},"Solution"),(0,o.kt)("p",null,"Una soluzione di un programma prolog pu\xf2:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Essere una soluzione positiva (Yes) (il goal \xe8 una conseguenza logica della teoria)."),(0,o.kt)("li",{parentName:"ul"},"Essere una soluzione negativa (No) (il goal non \xe8 una conseguenza logica della teoria)."),(0,o.kt)("li",{parentName:"ul"},"Un'eccezione (Halt) (si \xe8 verificato un problema nella risoluzione del programma).")),(0,o.kt)("h3",{id:"substitution"},"Substitution"),(0,o.kt)("p",null,"In caso di soluzione positiva \xe8 possibile che il solver fornisca una sostituzione. Una sostituzione\nmappa variabili a termini."),(0,o.kt)("h2",{id:"prologdsl"},"PrologDSL"),(0,o.kt)("p",null,"Il trait PrologDSL contiene i metodi e i meccanismi per poter esprimere i concetti appartenenti al mondo Prolog.\nInclude infatti dei metodi per costruire fatti, regole, atomi e variabili ma anche liste, congiunzioni e disgiunzioni\ndi goal."),(0,o.kt)("h2",{id:"termconvertible"},"TermConvertible"),(0,o.kt)("p",null,"Il trait TermConvertible fornisce un metodo per permettere a qualsiasi oggetto che lo implementa di vederlo come un\ntermine prolog."),(0,o.kt)("h2",{id:"termvisitor"},"TermVisitor"),(0,o.kt)("p",null,"TermVisitor \xe8 il trait che, se implementato da un termine o da un oggetto convertibile, permette di visitare l'albero\ndella struttura del termine."))}p.isMDXComponent=!0}}]);