"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[844],{3905:(e,a,t)=>{t.d(a,{Zo:()=>m,kt:()=>h});var r=t(7294);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var i=r.createContext({}),c=function(e){var a=r.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},m=function(e){var a=c(e.components);return r.createElement(i.Provider,{value:a},e.children)},p="mdxType",f={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},u=r.forwardRef((function(e,a){var t=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=c(t),u=n,h=p["".concat(i,".").concat(u)]||p[u]||f[u]||o;return t?r.createElement(h,l(l({ref:a},m),{},{components:t})):r.createElement(h,l({ref:a},m))}));function h(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var o=t.length,l=new Array(o);l[0]=u;var s={};for(var i in a)hasOwnProperty.call(a,i)&&(s[i]=a[i]);s.originalType=e,s[p]="string"==typeof e?e:n,l[1]=s;for(var c=2;c<o;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},672:(e,a,t)=>{t.r(a),t.d(a,{contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>i});var r=t(7462),n=(t(7294),t(3905));const o={title:"Scala project Template"},l="Prolog as Scala DSL",s={type:"mdx",permalink:"/PPS-22-Prolog-as-scalaDSL/",source:"@site/src/pages/index.md",title:"Scala project Template",description:"Prolog-as-scalaDSL is a library providing a DSL for writing Prolog programs in scala.",frontMatter:{title:"Scala project Template"}},i=[{value:"How to use",id:"how-to-use",level:2},{value:"Demo",id:"demo",level:2}],c={toc:i},m="wrapper";function p(e){let{components:a,...o}=e;return(0,n.kt)(m,(0,r.Z)({},c,o,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"prolog-as-scala-dsl"},"Prolog as Scala DSL"),(0,n.kt)("p",null,(0,n.kt)("img",{src:t(1553).Z,width:"895",height:"378"})),(0,n.kt)("p",null,"Prolog-as-scalaDSL is a library providing a DSL for writing Prolog programs in scala."),(0,n.kt)("h2",{id:"how-to-use"},"How to use"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Add the following library dependency in your build file.",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"for sbt:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre",className:"language-scala"},' libraryDependencies += "io.github.kelvindev15" % "prolog-as-scaladsl_3" % "<version>"\n'))),(0,n.kt)("li",{parentName:"ul"},"for gradle:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre",className:"language-kotlin"},'implementation("io.github.kelvindev15:prolog-as-scaladsl_3:<version>")\n'))))),(0,n.kt)("li",{parentName:"ol"},"Replace ",(0,n.kt)("inlineCode",{parentName:"li"},"<version>")," with the desired of latest version of the library.")),(0,n.kt)("h2",{id:"demo"},"Demo"),(0,n.kt)("p",null,"Using the DSL is as simple as extending the ",(0,n.kt)("inlineCode",{parentName:"p"},"PrologDSL")," trait. Let's write a program."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'object Demo extends PrologDSL:\n  def main(args: Array[String]): Unit =\n    val program = PrologProgram(Theory(\n      factOf(structOf(atomOf("father"), atomOf("abraham"), atomOf("isaac"))),\n      factOf(structOf(atomOf("father"), atomOf("terach"), atomOf("abraham"))),\n      ruleOf(\n        structOf(atomOf("grandfather"), varOf("X"), varOf("Y")),\n        structOf(atomOf("father"), varOf("X"), varOf("Z")) and\n          structOf(atomOf("father"), varOf("Z"), varOf("Y")))),\n    )\n\n    for\n      solution <- Solver solve (\n        program withGoal structOf(atomOf("father"), atomOf("abraham"), atomOf("isaac")))\n    do println(solution)\n')),(0,n.kt)("p",null,"Here's the output:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"},"Yes(father(abraham, isaac),Map())\n")),(0,n.kt)("p",null,"As you can tell the writing of the prolog program is a bit difficult since we had to specify what is a struct, what\nis an atom or a variable, etc... Fortunately we are in scala so we can take advantage of that:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val father = atomOf("father")\nval grandfather = atomOf("grandfather")\nval abraham = atomOf("abraham")\nval isaac = atomOf("isaac")\nval terach = atomOf("terach")\nval X = varOf("X")\nval Y = varOf("Y")\nval Z = varOf("Z")\n\nval program = PrologProgram(Theory(\n  factOf(structOf(father, abraham, isaac)),\n  factOf(structOf(father, terach, abraham)),\n  ruleOf(structOf(grandfather, X, Y), structOf(father, X, Z) and structOf(father, Z, Y))),\n)\n')),(0,n.kt)("p",null,"Now the program was easier to write, but, still we had to introduce a lot of variables in order to achieve that.\nLuckily the DSL come with some of predefined structures such as variables and moreover strings are automatically converted\nto atoms!"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val program = PrologProgram(theory(\n  factOf(structOf("father", "abraham", "isaac")),\n  factOf(structOf("father", "terach", "abraham")),\n  ruleOf(structOf("grandfather", X, Y), structOf("father", X, Z) and structOf("father", Z, Y))),\n)\n')),(0,n.kt)("p",null,"In order to resemble the prolog syntax, string can be invoked to create structures:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val program = PrologProgram(theory(\n  factOf("father"("abraham", "isaac")),\n  factOf("father"("terach", "abraham")),\n  ruleOf("grandfather"(X, Y), "father"(X, Z) and "father"(Z, Y)),\n))\n')),(0,n.kt)("p",null,'The grandfather rule can be written in a "more prolog" way as:'),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'"grandfather"(X, Y) :- ("father"(X, Z) &: "father"(Z, Y))\n')),(0,n.kt)("p",null,"Whenever a clause is expected (e.g the arguments of the theory method), structure are automatically converted to fact.\nSo here's a cleaner way to write the program."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val program = PrologProgram(theory(\n  "father"("abraham", "isaac"),\n  "father"("terach", "abraham"),\n  "grandfather"(X, Y) :- ("father"(X, Z) &: "father"(Z, Y)))\n)\n')),(0,n.kt)("p",null,"Let's make some other queries:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'for\n  goal <- Seq(\n    "grandfather"("abraham", "isaac"),\n    "father"(A, "isaac"),\n    "father"(F, S)\n  )\n  solution <- Solver solve (program withGoal goal)\ndo println(solution)\n\n/* OUTPUT:\n No(grandfather(abraham, isaac))\n Yes(father(A, isaac),Map(A -> abraham))\n Yes(father(F, S),Map(F -> abraham, S -> isaac))\n Yes(father(F, S),Map(F -> terach, S -> abraham))\n*/\n')),(0,n.kt)("p",null,"As you can see some solutions have a mapping (substitution). In this cases we can access a variable substitution directly\nfrom the solution:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'for\n  solution <- Solver solve (program withGoal "father"(F, S))\ndo\n  for\n    father <- solution(F)\n    son <- solution(S) \n  do println(s"$father is the father of $son")\n  \n/* OUTPUT\n abraham is the father of isaac\n terach is the father of abraham\n */\n')),(0,n.kt)("p",null,"Program may be written in a more declarative way. All we need is to mixin the ",(0,n.kt)("inlineCode",{parentName:"p"},"DeclarativeProlog")," trait."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'object Demo extends PrologDSL with DeclarativeProlog:\n  def main(args: Array[String]): Unit =\n    val program = prolog:\n      programTheory:\n        clause { "father"("abraham", "isaac") }\n        clause { "father"("terach", "abraham") }\n        clause { "grandfather"(X, Y) :- ("father"(X, Z) &: "father"(Z, Y)) }\n      goal:\n        "father"(F, S)\n        \n    for solution <- Solver solve program do println(solution)\n')),(0,n.kt)("p",null,"If you want, you may split your theory in a ",(0,n.kt)("inlineCode",{parentName:"p"},"staticTheory")," and a ",(0,n.kt)("inlineCode",{parentName:"p"},"dynamicTheory"),"\n(",(0,n.kt)("inlineCode",{parentName:"p"},"programTheory")," is an alias of `dynamicTheory)."),(0,n.kt)("p",null,"A Solver may be used just to satisfy goals in the following way:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'for solution <- Solver query member(X, list("a", "b", "c")) do println(solution)\n/*\n  Yes(member(X, [a, b, c]),Map(X -> a))\n  Yes(member(X, [a, b, c]),Map(X -> b))\n  Yes(member(X, [a, b, c]),Map(X -> c))\n  No(member(X, [a, b, c]))\n */\n')),(0,n.kt)("p",null,"Notice that ",(0,n.kt)("inlineCode",{parentName:"p"},"member")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"list")," and many others are facility methods to create their correspondent predicates."),(0,n.kt)("p",null,"The trait ",(0,n.kt)("inlineCode",{parentName:"p"},"TermConvertible")," gives you the possibility to interpret your object as if they were terms. You just need\nto specify how to convert them to term. Here's a cumbersome but explicative example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'def father(f: String, s: String): TermConvertible = new TermConvertible:\n  override def toTerm: Struct = "father"(f, s)\n')))}p.isMDXComponent=!0},1553:(e,a,t)=>{t.d(a,{Z:()=>r});const r=t.p+"assets/images/Prolog_as_scalaDSL_BOW-a53dfb0d7631556089c426ebe73b7bd8.png"}}]);