"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[449],{559:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>t,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=r(5893),a=r(1151);const o={sidebar_position:4,sidebar_label:"Implementazione"},t="Implementazione",l={id:"documentazione/implementation",title:"Implementazione",description:"Di seguito verranno riportate alcune rilevanti scelte implementative.",source:"@site/docs/documentazione/implementation.md",sourceDirName:"documentazione",slug:"/documentazione/implementation",permalink:"/PPS-22-Prolog-as-scalaDSL/docs/documentazione/implementation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,sidebar_label:"Implementazione"},sidebar:"docSidebar",previous:{title:"Design dettagliato",permalink:"/PPS-22-Prolog-as-scalaDSL/docs/documentazione/detailed_design"}},s={},c=[{value:"Programmazione funzionale",id:"programmazione-funzionale",level:2},{value:"Feature di linguaggio",id:"feature-di-linguaggio",level:2},{value:"Struttura dei package",id:"struttura-dei-package",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"implementazione",children:"Implementazione"}),"\n",(0,i.jsx)(n.p,{children:"Di seguito verranno riportate alcune rilevanti scelte implementative."}),"\n",(0,i.jsx)(n.h2,{id:"programmazione-funzionale",children:"Programmazione funzionale"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Strutture dati immutabili"}),": tutte le strutture dati realizzate (con poche eccezioni) sono immutabili. Ci si\naspetta dunque che nel caso in cui la libreria venga, ad esempio, utilizzata in un contesto di programmazione concorrente,\ngli aggiustamenti che dovranno essere apportati saranno minimi se non nulli.\nDi seguito un esempio di struttura dati immutabile."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"private case class PrologProgramImpl(\n  staticTheory: Theory,\n  dynamicTheory: Theory,\n  goal: Option[Term]\n) extends PrologProgram:\n  override def setStaticTheory(theory: Theory): PrologProgram =\n    PrologProgramImpl(theory, dynamicTheory, goal)\n  override def setDynamicTheory(theory: Theory): PrologProgram =\n    PrologProgramImpl(staticTheory, theory, goal)\n  override def withGoal(goal: Term): PrologProgram =\n    PrologProgramImpl(staticTheory, dynamicTheory, Some(goal))\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Higher-order functions"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'  object BinaryRecursiveStruct:\n    def wrapIfNecessary(strategy: Seq[Term] => BinaryRecursiveStruct)(args: Term*): Term = args.size match\n      case 0 => throw IllegalArgumentException("Cannot create a goal from an empty sequence")\n      case 1 => args.head\n      case _ => strategy(args)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Il linguaggio Scala offre supporto diretto al pattern Strategy, grazie all'esistenza delle funzioni ",(0,i.jsx)(n.em,{children:"higher-order"}),".\nDi seguito \xe8 riportato l'esempio in cui la strategia per binarizzare una sequenza di termini viene passata alla\nfunzione ",(0,i.jsx)(n.code,{children:"BinaryRecursiveStruct.wrapIfNecessary"})," tramite la funzione ",(0,i.jsx)(n.code,{children:"Conjunction.apply"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"object Conjunction:\n  def wrapIfNecessary(args: Term*): Term =\n    BinaryRecursiveStruct.wrapIfNecessary(Conjunction.apply)(args*)\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern matching"}),":\nLa struttura principale del linguaggio Prolog \xe8 il ",(0,i.jsx)(n.em,{children:"termine"}),". Si tratta di una struttura ad albero dove i nodi sono\na loro volta dei termini o suoi sottotipi. Il pattern matching \xe8 stato principalmente utile per determinare in maniera\nidiomatica il tipo dei nodi della struttura. Di seguito un esempio:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"object BinaryToFlatVisitor extends TermVisitor[Seq[Term]]:\n  override def visit(tuple: BinaryRecursiveStruct): Seq[Term] = tuple match\n    case Tuple(l, r @ Tuple(_, _)) => Seq(l) ++ visit(r)\n    case Tuple(l, r)               => Seq(l, r)\n"})}),"\n",(0,i.jsx)(n.p,{children:"ci\xf2 \xe8 reso possibile grazie alla destrutturazione di BinaryRecursiveStruct:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"object Tuple:\n  def unapply(tuple: BinaryRecursiveStruct): Option[(Term, Term)] =\n    Option((tuple.left, tuple.right))\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"feature-di-linguaggio",children:"Feature di linguaggio"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Companion objects"}),": Questa feature del linguaggio Scala ha permesso di mantenere incapsulate\nle implementazioni dei trait della libreria ed ottemperare all'item 64 di Effective Java (",(0,i.jsx)(n.em,{children:"Refer to object by their interfaces"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Inoltre tale meccanismo facilita l'implementazione del pattern ",(0,i.jsx)(n.em,{children:"Static Factory"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'trait Variable extends Term:\n  val name: String\n  // ...\nobject Variable:\n  def anonymous(): Variable = Var("_")\n  private case class Var(name: String) extends Variable:\n    override def asTerm: Term = this\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Implicit conversions\nIl meccanismo delle conversioni implicite \xe8 stato utilizzato nei casi in cui si \xe8 presentata un'incompatibilit\xe0 tra\ntipi. Ad esempio, il funtore di un predicato \xe8 un atomo il quale \xe8 a sua volta una sequenza di caratteri e dunque una stringa.\nPer questo motivo \xe8 stata introdotta una ",(0,i.jsx)(n.strong,{children:"given Conversion"})," che all'occorrenza converte le stringe in atomo e permette\ndi usare direttamente una stringa ogni volta che ci si aspetta un atomo."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'protected[dsl] trait DSLConversions:\n  dsl: PrologDSL =>\n  given Conversion[String, Atom] = atomOf(_)\n  given Conversion[AnyVal, Constant] = {\n    case boolean: Boolean      => if (boolean) "true" else "false"\n    case other: (Int | Double) => numOf(other)\n  }\n  given Conversion[Struct, Fact] = factOf(_)\n  given Conversion[Seq[Term], PrologList] = list(_*)\n  given Conversion[TermConvertible, Term] = _.toTerm\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Traits"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Self type"}),": Nella porzione di codice precedente viene esemplificato l'utilizzo che \xe8 stato fatto dei\n",(0,i.jsx)(n.em,{children:"self type"}),". Il trait DSLConversion potr\xe0 essere utilizzato solo in combinazione con il trait PrologDSL.\nChi utilizzer\xe0 la libreria non potr\xe0 sfruttare le conversioni implicite se non nel contesto di un PrologDSL."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Template method pattern\nIl seguente trait svolge il ruolo di classe astratta. I metodi ",(0,i.jsx)(n.code,{children:"lazySolve"}),", ",(0,i.jsx)(n.code,{children:"solutionOf"})," e ",(0,i.jsx)(n.code,{children:"hasSolutionOf"}),"\nsono dei metodi ",(0,i.jsx)(n.em,{children:"template"}),". Essi richiedono agli implementatori del trait forniscano di implementare\nsolo il metodo ",(0,i.jsx)(n.code,{children:"solve"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait Solver:\n  def solve(program: PrologProgram): Iterator[Solution]\n  def lazySolve(program: PrologProgram): LazyList[Solution] =\n    solve(program).to(LazyList)\n  def solutionsOf(program: PrologProgram): Seq[Solution] =\n    solve(program).to(Seq)\n  def hasSolutionFor(program: PrologProgram): Boolean =\n    val solutions = solve(program)\n    solutions.hasNext && solutions.next().isInstanceOf[Solution.Yes]\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Extension functions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pimp my library"}),": pattern fondamentale per la costruzione del dsl. Ha permesso di aggiungere funzionalit\xe0\na classi gi\xe0 definite senza modificarne l'interfaccia."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"protected[dsl] trait DSLExtensions:\n  dsl: PrologDSL =>\n  extension (atom: Atom)\n    def apply(terms: Term*): Struct = Struct(atom, terms*)\n  extension (struct: Struct)\n    def :-(body: Term): Rule = Rule(struct, body)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Le estensioni definite nel trait DSLExtensions abilitano sintassi come la seguente per la creazione di regole:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val rule: Rule = "grandfather"(X, Y) :- ("father"(X, Z) &: "father"(Z, Y))\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Context functions\nPer abilitare la seguente sintassi:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'prolog:\n  programTheory:\n    clause { "father"("abraham", "terach") }\n  goal:\n    "father"(X, "terach")\n'})}),"\n",(0,i.jsx)(n.p,{children:"che di fatto costituisce un builder per un programma prolog, \xe8 stato fatto uso delle context function."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"var prologProgram = ???  \ndef prolog(program: PrologProgram ?=> Unit): PrologProgram =\n  prologProgram = PrologProgram.empty\n  given p: PrologProgram = prologProgram\n  program\n  prologProgram\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Il metodo ",(0,i.jsx)(n.code,{children:"prolog"})," ha un parametro ",(0,i.jsx)(n.code,{children:"program"})," il cui tipo \xe8 quello di una funzione che accetta come unico parametro un ",(0,i.jsx)(n.code,{children:"PrologProgram"}),"\nche si aspetta di trovare nel contesto come ",(0,i.jsx)(n.em,{children:"given instance"}),". Ci\xf2 vale anche per i metodi ",(0,i.jsx)(n.code,{children:"programTheory"})," e ",(0,i.jsx)(n.code,{children:"goal"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"struttura-dei-package",children:"Struttura dei package"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"package_diagram",src:r(492).Z+"",width:"543",height:"258"})})]})}function m(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},492:(e,n,r)=>{r.d(n,{Z:()=>i});const i=r.p+"assets/images/packages-2866f497cf43e7a6c91aadf1189e501c.png"},1151:(e,n,r)=>{r.d(n,{Z:()=>l,a:()=>t});var i=r(7294);const a={},o=i.createContext(a);function t(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);