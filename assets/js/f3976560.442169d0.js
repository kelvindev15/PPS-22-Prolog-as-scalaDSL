"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[844],{3905:(e,a,t)=>{t.d(a,{Zo:()=>c,kt:()=>d});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),p=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},c=function(e){var a=p(e.components);return n.createElement(s.Provider,{value:a},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},f=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(t),f=r,d=m["".concat(s,".").concat(f)]||m[f]||u[f]||o;return t?n.createElement(d,l(l({ref:a},c),{},{components:t})):n.createElement(d,l({ref:a},c))}));function d(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=f;var i={};for(var s in a)hasOwnProperty.call(a,s)&&(i[s]=a[s]);i.originalType=e,i[m]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=t[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}f.displayName="MDXCreateElement"},672:(e,a,t)=>{t.r(a),t.d(a,{contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var n=t(7462),r=(t(7294),t(3905));const o={title:"Scala project Template"},l="Prolog as Scala DSL",i={type:"mdx",permalink:"/PPS-22-Prolog-as-scalaDSL/",source:"@site/src/pages/index.md",title:"Scala project Template",description:"Prolog-as-scalaDSL is a library providing a DSL for writing Prolog programs in scala.",frontMatter:{title:"Scala project Template"}},s=[{value:"How to use",id:"how-to-use",level:2},{value:"Demo",id:"demo",level:2},{value:"Other features",id:"other-features",level:2},{value:"Conjunction and conjunction of goals",id:"conjunction-and-conjunction-of-goals",level:3},{value:"Lists",id:"lists",level:3},{value:"Builtin predicates",id:"builtin-predicates",level:3},{value:"Use cases",id:"use-cases",level:3}],p={toc:s},c="wrapper";function m(e){let{components:a,...o}=e;return(0,r.kt)(c,(0,n.Z)({},p,o,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"prolog-as-scala-dsl"},"Prolog as Scala DSL"),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(1553).Z,width:"895",height:"378"})),(0,r.kt)("p",null,"Prolog-as-scalaDSL is a library providing a DSL for writing Prolog programs in scala."),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Add the following library dependency in your build file.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"for sbt:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala"},' libraryDependencies += "io.github.kelvindev15" % "prolog-as-scaladsl_3" % "<version>"\n'))),(0,r.kt)("li",{parentName:"ul"},"for gradle:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'implementation("io.github.kelvindev15:prolog-as-scaladsl_3:<version>")\n'))))),(0,r.kt)("li",{parentName:"ol"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},"<version>")," with the desired of latest version of the library.")),(0,r.kt)("h2",{id:"demo"},"Demo"),(0,r.kt)("p",null,"Using the DSL is as simple as extending the ",(0,r.kt)("inlineCode",{parentName:"p"},"PrologDSL")," trait. Let's write a program."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'object Demo extends PrologDSL:\n  def main(args: Array[String]): Unit =\n    val program = PrologProgram(Theory(\n      factOf(structOf(atomOf("father"), atomOf("abraham"), atomOf("isaac"))),\n      factOf(structOf(atomOf("father"), atomOf("terach"), atomOf("abraham"))),\n      ruleOf(\n        structOf(atomOf("grandfather"), varOf("X"), varOf("Y")),\n        structOf(atomOf("father"), varOf("X"), varOf("Z")) and\n          structOf(atomOf("father"), varOf("Z"), varOf("Y")))),\n    )\n\n    for\n      solution <- Solver solve (\n        program withGoal structOf(atomOf("father"), atomOf("abraham"), atomOf("isaac")))\n    do println(solution)\n')),(0,r.kt)("p",null,"Here's the output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Yes(father(abraham, isaac),Map())\n")),(0,r.kt)("p",null,"As you can tell the writing of the prolog program is a bit difficult since we had to specify what is a struct, what\nis an atom or a variable, etc... Fortunately we are in scala so we can take advantage of that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val father = atomOf("father")\nval grandfather = atomOf("grandfather")\nval abraham = atomOf("abraham")\nval isaac = atomOf("isaac")\nval terach = atomOf("terach")\nval X = varOf("X")\nval Y = varOf("Y")\nval Z = varOf("Z")\n\nval program = PrologProgram(Theory(\n  factOf(structOf(father, abraham, isaac)),\n  factOf(structOf(father, terach, abraham)),\n  ruleOf(structOf(grandfather, X, Y), structOf(father, X, Z) and structOf(father, Z, Y))),\n)\n')),(0,r.kt)("p",null,"Now the program was easier to write, but, still we had to introduce a lot of variables in order to achieve that.\nLuckily the DSL come with some of predefined structures such as variables and moreover strings are automatically converted\nto atoms!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val program = PrologProgram(theory(\n  factOf(structOf("father", "abraham", "isaac")),\n  factOf(structOf("father", "terach", "abraham")),\n  ruleOf(structOf("grandfather", X, Y), structOf("father", X, Z) and structOf("father", Z, Y))),\n)\n')),(0,r.kt)("p",null,"In order to resemble the prolog syntax, string can be invoked to create structures:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val program = PrologProgram(theory(\n  factOf("father"("abraham", "isaac")),\n  factOf("father"("terach", "abraham")),\n  ruleOf("grandfather"(X, Y), "father"(X, Z) and "father"(Z, Y)),\n))\n')),(0,r.kt)("p",null,'The grandfather rule can be written in a "more prolog" way as:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'"grandfather"(X, Y) :- ("father"(X, Z) &: "father"(Z, Y))\n')),(0,r.kt)("p",null,"Whenever a clause is expected (e.g the arguments of the theory method), structure are automatically converted to fact.\nSo here's a cleaner way to write the program."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val program = PrologProgram(theory(\n  "father"("abraham", "isaac"),\n  "father"("terach", "abraham"),\n  "grandfather"(X, Y) :- ("father"(X, Z) &: "father"(Z, Y)))\n)\n')),(0,r.kt)("p",null,"Let's make some other queries:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'for\n  goal <- Seq(\n    "grandfather"("abraham", "isaac"),\n    "father"(A, "isaac"),\n    "father"(F, S)\n  )\n  solution <- Solver solve (program withGoal goal)\ndo println(solution)\n\n/* OUTPUT:\n No(grandfather(abraham, isaac))\n Yes(father(A, isaac),Map(A -> abraham))\n Yes(father(F, S),Map(F -> abraham, S -> isaac))\n Yes(father(F, S),Map(F -> terach, S -> abraham))\n*/\n')),(0,r.kt)("p",null,"As you can see some solutions have a mapping (substitution). In this cases we can access a variable substitution directly\nfrom the solution:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'for\n  solution <- Solver solve (program withGoal "father"(F, S))\ndo\n  for\n    father <- solution(F)\n    son <- solution(S) \n  do println(s"$father is the father of $son")\n  \n/* OUTPUT\n abraham is the father of isaac\n terach is the father of abraham\n */\n')),(0,r.kt)("p",null,"Program may be written in a more declarative way. All we need is to mixin the ",(0,r.kt)("inlineCode",{parentName:"p"},"DeclarativeProlog")," trait."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'object Demo extends PrologDSL with DeclarativeProlog:\n  def main(args: Array[String]): Unit =\n    val program = prolog:\n      programTheory:\n        clause { "father"("abraham", "isaac") }\n        clause { "father"("terach", "abraham") }\n        clause { "grandfather"(X, Y) :- ("father"(X, Z) &: "father"(Z, Y)) }\n      goal:\n        "father"(F, S)\n        \n    for solution <- Solver solve program do println(solution)\n')),(0,r.kt)("p",null,"If you want, you may split your theory in a ",(0,r.kt)("inlineCode",{parentName:"p"},"staticTheory")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamicTheory"),"\n(",(0,r.kt)("inlineCode",{parentName:"p"},"programTheory")," is an alias of `dynamicTheory)."),(0,r.kt)("p",null,"A Solver may be used just to satisfy goals in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'for solution <- Solver query member(X, list("a", "b", "c")) do println(solution)\n/*\n  Yes(member(X, [a, b, c]),Map(X -> a))\n  Yes(member(X, [a, b, c]),Map(X -> b))\n  Yes(member(X, [a, b, c]),Map(X -> c))\n  No(member(X, [a, b, c]))\n */\n')),(0,r.kt)("p",null,"Notice that ",(0,r.kt)("inlineCode",{parentName:"p"},"member")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," and many others are facility methods to create their correspondent predicates."),(0,r.kt)("p",null,"The trait ",(0,r.kt)("inlineCode",{parentName:"p"},"TermConvertible")," gives you the possibility to interpret your object as if they were terms. You just need\nto specify how to convert them to term. Here's a cumbersome but explicative example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'def father(f: String, s: String): TermConvertible = new TermConvertible:\n  override def toTerm: Struct = "father"(f, s)\n')),(0,r.kt)("h2",{id:"other-features"},"Other features"),(0,r.kt)("h3",{id:"conjunction-and-conjunction-of-goals"},"Conjunction and conjunction of goals"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'object Demo extends PrologDSL:\n  def main(args: Array[String]): Unit =\n    // Conjunctions\n    println(&&("a", "b", "c")) // a, b, c\n    println("a" &: "b" &: "c")\n    println("a" and "b" and "c")\n    // Disjunctions\n    println(||("a", "b", "c")) // a; b; c\n    println("a" |: "b" |: "c")\n    println("a" or "b" or "c")\n')),(0,r.kt)("h3",{id:"lists"},"Lists"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'object Demo extends PrologDSL:\n  def main(args: Array[String]): Unit =\n    println(list("a", "b", "c")) // [a, b, c]\n    println(cons("a", cons("b", cons("c", nil)))) // [a, b, c]\n    println(cons(X, Y)) // [X, Y]\n    println(cons(X)(Y)) // emulates [X | Y]\n    println(head(1, 2, 3) | X) // emulates [1, 2, 3 | X]\n')),(0,r.kt)("h3",{id:"builtin-predicates"},"Builtin predicates"),(0,r.kt)("p",null,"Here's a list of prolog builtins available in the library:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"true/0"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"fail/0"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"var/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"nonvar/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"atom/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"number/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"atomic/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"clause/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"asserta/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"assertz/1"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"retract/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"member/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ground/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"append/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"call/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"once/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"not/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"functor/3"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"arg/3"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"=../2"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"findall/3"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"op/3"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"length/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[]/0"),",",(0,r.kt)("inlineCode",{parentName:"p"},"atom_chars/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"number_chars/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"!/0"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"repeat/0"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"call/1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"\\\\+/1"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"=\\1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"==/2")," (as strictEq), ",(0,r.kt)("inlineCode",{parentName:"p"},"op/3"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"is/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"+/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"-/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"*/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"//2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"///2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"mod/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"=:=/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"=\\\\=/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"</2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">/2"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},">=/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"=</2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@</2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@>/2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@=</2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@>=/2")),(0,r.kt)("h3",{id:"use-cases"},"Use cases"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/kelvin-olaiya/PPS-22-prolog-as-scalaDSL-demo"},"Chess Project")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/jahrim"},"@jahrim")," et al.")))}m.isMDXComponent=!0},1553:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/Prolog_as_scalaDSL_BOW-a53dfb0d7631556089c426ebe73b7bd8.png"}}]);